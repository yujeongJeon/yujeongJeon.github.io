### Chapter 04 - 테스트 구축하기

- 테스트 코드가 있어야 제대로 리팩터링 할 수 있다.
- 테스트 코드가 있으면 효율이 높아진다.

- 자가 테스트 코드의 가치
    - 테스트를 완전히 자동화하자. 결과 체크까지.
    - 테스트 코드가 있으면 회귀 버그, 즉 새로운 기능 추가로, 기존에 잘 동작하던 기능에서 버그가 발생한 경우를 거의 즉시 찾아낼 수 있다.
    - 테스트 코드로 스펙 정리 & 정의 -> 구현 -> 테스트 -> 리팩토링 = TDD
    - 리팩토링하려면 테스트 코드는 필요하다.

<br>

- 테스트할 샘플 코드
    - ![sampleCode](./images/sampleCode.jpeg)
        - 엑셀과 비슷한 기능이라 생각하면 된다.
        - 비지니스 로직은 생산자를 표현하는 Producer, 지역 전체를 표현하는 Province 두 개로 구성된다.

        - ![provinceClass](./images/provinceClass.jpeg)
            - Province 클래스는 생성자를 통해 데이터를 받고, 이를 Private 변수에 할당한다.
            - Province 클래스는 게터와 세터로 이루어진 다양한 데이터 접근자들을 가지고 있다.
            - Province 클래스는 생상 부족분, 수익을 계산하는 멤버함수들을 가지고 있다.
        
        - sampleProvinceData 함수는 provinceClass의 인스턴스를 만들 때 생성자로 데이터를 밀어 넣어주는 함수다. 해당 함수의 테스트는 반환 값으로 Province 객체를 생성해보면 된다.

        - ![producerClass](./images/producerClass.jpeg)
            - Producer 클래스는 주로 데이터 저장소로 쓰인다. (게터 + 세터 + 내부변수)



### 4.3 - 4.7 테스트 코드 실습

[province 클래스](./examples/province.js)

[producer 클래스](./examples/producer.js)

[Mocha, Chai로 작성한 테스트 코드](./examples/province.test.js)



**참고 : [chai 라이브러리 Document](https://www.chaijs.com/api/bdd/)**



#### BDD

BDD는 (Behavior Driven Development )로 TDD를 근간으로 파생된 개발 방법입니다.

TDD에서 한 발 더 나아가 테스트케이스 자체가 요구사양이 되도록 하는 개발방법입니다.

 

BDD를 통해 개발을 하게 된다면 테스트 메소드의 이름을 

"이 클래스가 어떤 행위를 해야한다 (should do someting)" 라는 식의 문장으로 작성하여 

행위에 대한 테스트에 집중할 수 있습니다.



BDD는 시나리오를 기반으로 테스트 케이스를 작성하며 함수 단위 테스트를 권장하지 않습니다.

[출처](https://beomseok95.tistory.com/293)

먼저 TDD는 코드 자체에 집중한 테스트 코드를 작성하기 때문에 BDD에서 말하는 Side Effect를 포함하고 있는 경우가 많고, 코드에 집중된 테스트 코드는 결국 이것만으로 비지니스 요구 사항에 따른 로직을 파악하기 어려워진다. 또한 이러한 점은 결국 비지니스 요구 사항이 변경되었을 때 기존 비지니스 로직과 테스트 코드를 수정하는데 있어 비교적 BDD 보다 큰 코스트를 가져다 주는 단점이 된다.

 

BDD는 TDD를 포함하고 있는 개념이기 때문에 테스트 주도 개발 자체로만 봤을 때는 두 개를 나누는 것이 큰 의미가 없지만 코드 자체에 집중된 테스트 코드로 인해 발생하는 TDD의 단점을 BDD에서는 Side Effect를 제외한 Behavior 기반으로 비지니스 요구 사항에 집중한 테스트 코드를 작성하기 때문에 좀 더 의도와 목적을 구체적으로 한 테스트 코드 작성 방법이라고 할 수 있다.

[출처](https://yorr.tistory.com/26)



#### 픽스쳐

- 픽스쳐 : 테스트에 필요한 데이터와 객체

- 테스트마다 겹치는 픽스쳐 사용 시, 유효범위를 옮겨 테스트끼리 상호작용하는 공유 픽스쳐가 아닌 각 테스트마다 새로 설정되는 beforeEach문에서 생성합니다.

- **픽스쳐를 사용하는 이유**

  모든 테스트가 똑같은 픽스쳐에 기초하여 검증을 수행하기를 보장하여 테스트할 속성을 다양하게 발굴할 수 있기 때문입니다. 

  beforeEach문은 테스트에 기초가 되는 픽스쳐(이하 표준 픽스쳐)를 사용함을 명시하는 역할을 하기도 합니다. 

  동료 개발자들이 테스트 코드를 읽을 때 describe문의 모든 테스트가 똑같은 표준 픽스쳐로부터 시작함을 쉽게 인지할 수 있습니다.



#### 테스트 패턴

- given-when-expect (setup-exercise-verify, arrange-act-assert)

- 일반적으로 하나의 테스트에 한 개의 expect(검증)가 존재하는 것을 권장



#### 테스트 코드 작성 시 유의할 점

- 성공하기 위해서 작성하는 테스트 코드는 의미없을 수 있습니다. 실패해야 할 상황에서는 반드시 실패하게 작성합니다.
  - 일시적으로 오류를 주입해봅니다.
- 적어도 하루에 한 번 전체 테스트를 돌리고, 작성중인 코드는 최소한 몇 분 간격으로 테스트할 것을 권장합니다.
  - 추가한 코드에 문제는 없는지
  - 리팩터링하면서 실수한 것은 없는지
- 의식적으로 테스트를 망가뜨리는 경계 조건(문제가 생길 수 있는 조건들)을 생각해보고 집중 테스트해봅니다.
- 테스트는 어느 수준까지 작성? 함수에서 가장 위험한 부분, 즉 오류가 생길 수 있는 부분에 집중합니다.
- 테스트는 한번 작성하고 완성이 아니라 기능추가와 리팩터링을 하는 와중에도 지속적으로 보강합니다. 
  신규 기능 추가에 따른 신규 테스트 코드 작성 뿐만 아니라 기존에 작성한 테스트 코드가 명확한지, 더 이해하기 쉽게 작성할 수 있는지 확인합니다.
- 버그를 발견하는 즉시 그 버그를 테스트하는 테스트코드도 함께 작성하는 습관을 기릅니다.

> 버그 리포트를 받으면 가장 먼저 그 버그를 드러내는 단위 테스트부터 작성하자.

- 테스트의 품질은 어떻게 알 수 있을까? 기준이 매우 주관적이지만 중요한 것은 우리가 테스트 코드를 작성함으로써 그 기준에 대한 믿음을 갖는 것입니다.
  테스트 결과가 모두 성공이라면 리팩터링 과정에서 버그가 없다고 확신할 수 있습니다.

